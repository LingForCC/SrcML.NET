/******************************************************************************
 * Copyright (c) 2013 ABB Group
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Patrick Francis (ABB Group) - initial API, implementation, & documentation
 *  Vinay Augustine (ABB Group) - initial API, implementation, & documentation
 *****************************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace ABB.SrcML.Data {
    /// <summary>
    /// The data archive is an incrementally updating data container.
    /// </summary>
    /// <example>
    /// <code>
    /// var sourceFolder = new FileSystemSourceFolder("path to folder");
    /// var archive = new SrcMLArchive(sourceFolder);
    /// 
    /// // this should generate a data archive for the given srcML archive
    /// // when we start serializing data, we should consider how the location of the data can be stored in the srcmL archive
    /// // calling "DataArchive" on a srcML archive that already has data should transparently load the existing data
    /// DataArchive data = new DataArchive(archive);
    ///
    /// // testDeclaration is some declaration within archive
    /// var testDeclaration = new XElement(SRC.Declaration, "test data");
    /// 
    /// // The TypeUse object represents the context that the type is being used in
    /// TypeUse typeUseForDeclaration = new TypeUse(testDeclaration);
    /// TypeDefinition typeInfo = data.ResolveType(typeUseForDeclaration);
    /// 
    /// // one of the thing we should be able to do is get the original XML. Behind the scenes, this relies on using XPath queries
    /// // generated by Extensions.GetXPath()
    /// XElement typeXml = typeInfo.GetXElement();
    /// TypeUse parentType = typeInfo.ParentTypes.First();
    /// XElement parentXml = data.ResolveType(parentType).GetXElement();
    /// </code>
    /// </example>
    public class DataArchive {
        private Scope globalScope;
        private Dictionary<Language, AbstractCodeParser> Parser;
        public SrcMLArchive Archive { get; private set; }

        /// <summary>
        /// Create a data archive for the given srcML archive. It will subscribe to the <see cref="SrcMLArchive.SourceFileChanged"/> event.
        /// </summary>
        /// <param name="archive">The archive to monitor for changes.</param>
        public DataArchive(SrcMLArchive archive) {
            this.Archive = archive;
            this.Archive.SourceFileChanged += Archive_SourceFileChanged;
            InitializeData();
        }

        public void Clear() {
            globalScope = null;
            //TODO: clear any other data structures as necessary
        }

        public void AddFile(string sourceFile) {
            var unit = Archive.GetXElementForSourceFile(sourceFile);
            AddFile(unit);
        }

        public void AddFile(XElement fileUnitElement) {
            var fileLanguage = SrcMLElement.GetLanguageForUnit(fileUnitElement);
            Scope resultScope = null;
            AbstractCodeParser parserForUnit;
            if(Parser.TryGetValue(fileLanguage, out parserForUnit)) {
                resultScope = parserForUnit.ParseFileUnit(fileUnitElement);
            }
            
            if(resultScope != null) {
                globalScope = globalScope != null ? globalScope.Merge(resultScope) : resultScope;
            }
            //TODO: update other data structures as necessary
        }

        public void RemoveFile(string sourceFile) {
            //globalScope.RemoveFile(sourceFile);
            throw new NotImplementedException();
        }


        public TypeDefinition ResolveType(XElement variableDeclarationElement) {
            //var typeUse = new TypeUse(variableDeclarationElement);
            //return ResolveType(typeUse);
            throw new NotImplementedException();
        }

        public TypeDefinition ResolveType(TypeUse typeUse) {
            throw new NotImplementedException();
        }


        #region Private Methods
        private void InitializeData() {
            Clear();
            foreach(var unit in Archive.FileUnits) {
                AddFile(unit);
            }
        }

        private void SetupParsers() {
            Parser = new Dictionary<Language, AbstractCodeParser>() {
                { Language.CPlusPlus, new CPlusPlusCodeParser() },
                { Language.Java, new JavaCodeParser() },
            };
        }

        private void Archive_SourceFileChanged(object sender, FileEventRaisedArgs e) {
            switch(e.EventType) {
                case FileEventType.FileChanged:
                    // Treat a changed source file as deleted then added
                    RemoveFile(e.SourceFilePath);
                    goto case FileEventType.FileAdded;
                case FileEventType.FileAdded:
                    AddFile(e.SourceFilePath);
                    break;
                case FileEventType.FileDeleted:
                    RemoveFile(e.SourceFilePath);
                    break;
                case FileEventType.FileRenamed:
                    // TODO: could a more efficient rename action be supported within the data structures themselves?
                    RemoveFile(e.OldSourceFilePath);
                    AddFile(e.SourceFilePath);
                    break;
            }
        }

        #endregion

    }
}
